% $Id$

\chapter{SGML, XML and DTD's}
\label{cha:sgml-xml-and-dtd's}

\mycitation{If you don't read the manual before you enter the
    dungeon, you might end up being killed}{Rumour in the Nethack
  computer game}{about 1993}

A major ingredient in developing large, complex systems with several
layers of data and meta-data, is the ability to \textit{abstract}
between different levels of the system.

\begin{itemize}
\item
  
  \textit{Operating systems} provide the ``file'' abstraction, so the
  programmer does not have to think about the underlying hardware when
  reading and writing information, and these operations are normally
  optimized for speed.

\item
  
  Expensive printers provide the \textit{PostScript language} which is
  an abstraction for ``electronic paper''.  Any Postscript file can be
  printed to any PostScript printer, without considering the specifics
  of the device.  This was a major step forward from the traditional
  matrix printer where the application had to generate bitmaps for the
  printer to print.
  
\item
  
  \textit{Programming languages}, like C, provides the abstraction of
  a ``virtual machine''.  The programmer does not have to worry about
  how large an integer, and how the best way to implement a loop on
  this particular processor is.  The compiler takes care of that,
  leaving the programmer to concentrate on problems at a higher
  abstraction level.
  
\end{itemize}



The same need arose in the printing industry, where SGML (Standard
General Markup Language) was developed in
\myurl{http://www.sgmlsource.com/history/roots.htm}{the late sixties
and early seventies} to facilitate a transfer from ``specific coding''
to ``generic coding'' (Goldfarb mentions using ``heading'' instead of
``format-17'').  This allows authors to concentrate on \textit{what}
they write, instead of \textit{how} it is presented.  In Goldfarb's
own words in 1971:

\begin{quote}
  The principle of separating document description from application
  function makes it possible to describe the attributes common to all
  documents of the same type. ... [The] availability of such 'type
  descriptions' could add new function to the text processing system.
  Programs could supply markup for an incomplete document, or
  interactively prompt a user in the entry of a document by displaying
  the markup. A generalized markup language then, would permit full
  information about a document to be preserved, regardless of the way
  the document is used or represented.
\end{quote}

Today, almost 30 years later, this is coming to the users of the world
wide web, as the presenting technology moves into the web browsers -
with XML being defined as a subset of SGML - and they will be able to
fully present XML documents individually tailored to the users
preferences.  The author can provide richly annotated content, along
with a suggested way to view the content (in form of a style sheet).
The user may freely choose override some or all of these suggestions.

This is a radical change from the current situation where HTML allows
an information provider to be so specific in markup that it makes it
unusable in some browsers, and without any means for a user to specify
otherwise.    A sample is the font size change commands, which can
render a site totally unreadable in Netscape.

Hopefully the mechanisms for user customizations will be so well
developed when XML is commonplace in browsers and web sites, that this
can be disabled.

\textsf{I expect when this happens that} a standard for XML documents
will quickly arise, providing authors with a good way to provide much
better markup for search engines and web crawlers.    Already now
XML-editors are popping up everywhere --  it will be very interesting
to see what they can do in 5 years.


% Looking from the DocBook DTD's this \textsf{section} describes XML,
% how it was developed from SGML inspired by the short comings of HTML,
% and how it is used,` including viewing, authoring, and conversions
% (transforms, formatting).

\section{``HTML is a SGML DTD'' - the concepts}

Table~\vref{tab:programming-langugages-and-html} shows how the most
frequently used acronyms relate when mapped to the programming domain.
See section~\vref{cha:terms-and-concepts} for the full descriptions.


\begin{table}[htbp]
  \begin{center}
    \begin{tabular}{|l|l|}
      \hline\hline
      \textbf{Documents} &  \textbf{Programs} \\
      \hline
      SGML &Family of programming \\
           & languages  (C/Pascal/Lisp...) \\
      \hline
      XML  & Another family of programming \\
           & languages. (XML is a subset of SGML) \\
      \hline
      DTD  & \textsf{Backus}-Naur notation of a \\
           & given language, defining how it looks\\
      \hline
      HTML & A certain programming language\\
           & like C \\
      \hline
      XHMTL & Another programing language like Java \\
           & Well written programs can run both in C and Java\\
      \hline
      DSSSL & A report generator which takes a XML program \\
           & as input and produce a report, another\\
           & program or something else \\
      \hline
      XSL  & A report generator which takes a XML program \\
           & as input and produce a report, another\\
           & program or something else \\
      \hline
    \end{tabular}
    \caption{The analogy between programming languages and SGML}
    \label{tab:programming-langugages-and-html}
  \end{center}
\end{table}

Basically SGML (Standard General Markup Language) covers a large
family of document markup languages, which all share that a given
SGML-document \textit{must} comply to a DTD (Document Type
Definition).  DSSSL is used to convert a SGML document into something
else.  DSSSL's are written in a Scheme like language (see
\cite{Dybvig:1996:SPL} for a reference manual).

XML is a light-weight version of SGML designed to be embeddable in a
browser.  XML-documents \textit{may} comply to a DTD, or be
stand-alone (``DTD-less'').  XSL is used to convert a XML document
into another XML document (XSLT) or into the generic page description
language XSL-Formatting Objects (XSLFO).

XHTML is a XML-version designed to be presentable by HTML-4.0
browsers.


\section{The author should provide content, not do layout}

SGML came originally to because the authors at IBM were not
consistently marking their documents up, resulting in suboptimal
documents.  This was because they were doing physical markup instead
of logical markup.

\begin{my-detour}
Modern word processors have been constructed around the ``What you see
is what you get'' paradigm, where a great deal of effort has been
spent on allowing the user to see exactly on screen what would be
printed on paper.   Unfortunately the limited resolution and size of a modern
computer monitor cannot show the whole page in high resolution, and
the user must therefore work in small ``regions'' without being able
to see the whole page, or perhaps even several pages \textsf{A tufte
  reference here?}.  Microsoft Word provides a draft mode where just
the text is shown without markup;  WordPerfect provides a ``Reveal
Codes'' mode where the user can edit the text along with the tags.
\end{my-detour}
  
The most recent versions of Word and WordPerfect \textsf{wp9 should
  have sgml builtin} have had styles built
in, where the user could specify ``heading'' and similar categories
for selected text, but have been very passive in helping users to
employ these categories, meaning that most of these
document have had almost no semantic markup, but only visual markup.

In combination with this the web publishing tools by Microsoft and
others have blatantly ignored web standards, and used all kinds of
font modifying tags instead of the HTML-tags conveying \textit{meaning}
about the text.  These tags often implement the particular settings
that the author had on her word processor, so that the author is
effectively doing layout on the web.

This is not a new phenonomen, however.  The best way to typeset
mathematics have been the \myurl{http://www.tug.org}{\protect{\LaTeX}
  system}, (see section~\textsf{ref{sec:tex-and-latex}}) where the
author basically is told to write what she wants to and let {TeX} do
the rendering.  Even so, it is often very tempting even for the most
dedicated purist to want to change the layout to make a small visual
change, simply because they \textit{can}.  Unfortunately very few have
the expertise to do this right, so the changes usually make it worse.
I have seen a book where the author had prepared camera-ready copy for
his {\LaTeX}-document.  The book was printed in A5, but he had
apparently handled this merely by increasing the margins of a normal
page, and nothing else.  The result was that the layout looked awkward
- the line spacing seemed too large for the page.  This would not have
happened if a professional layouter had produced the book!

A layouter may also want to change the whole layout of a book, for
example if a new edition is to be part of a series with another
distinct style.  The publisher may want to turn the book into webpages
or a CD-ROM, or into a Braille version for blind persons.  It might
even be read aloud by a computer.

\textsf{HER SKAL O'REILLY DIMSEN IND!}

It should not bother the author during the writing process how the
finished document will look, as long as she marks up the document
appropriately, providing suffiecent meta-data about the content.

As the possible annotations are decided by the DTD, it is important to
choose a DTD carefully.  A well annotated document can be used for
many purposes, not all of which was envisioned when the document was
written.  Ten years ago no one had heard about the world wide web -
within the next few years, it will probably be the main use of SGML in
the world.


% \textsf{!!} The \textsf{needs of blind people} are very different
% from the \textsf{needs of mobile phone users}, yet 

% \subsection{The design and evolution of SGML}

% \framepage{15cm}{{Look up SGML history when/where/whom/\emph{WHY}}.
%   What does SGML do well?  Why is it so?  Initially hard to write in.
%   Development of DTD's to use in applications, with Stylesheets (FOSI,
%   DSSSL (when)).  Development of tools for making writing easier
%   (complex, expensive, slow).  Use liking to printer drivers for
%   printers, which was sweeped away by PostScript for LaserPrinters
%   (bitmaps are too hard to handle - talk about Stibo rendering in 2400
%   dpi to guarantee idential prints).}




\section{The \textsf{creation} of HTML}

\textsf{Look up creation of HTML on the net.  Look for reasons why HTML
  was chosen to be a SGML DTD instead of e.g. Windows Help, or
  something else}.

\myurl{http://www.w3.org/History/19921103-hypertext/hypertext/WWW/MarkUp/MarkUp.html}{The
  w3c have notes and DTD's describing the first versions of HTML}.



\framepage{15cm}{
  HTML: 1.0 (original, simple, $<$hr$>$ tag was added
  due to popular request), 2.0, 3.0 never made it, 3.2 tables, 4.0 w3c
  straightens up things.  Netscape added new tags \emph{ad hoc} often.
  In the mean time HTML has been made to do things it was never meant
  to do originally, for presentation purposes (large imagemaps in
  tables without any textual information), and there is still a need
  for new features that designers want.  \emph{W3C saw that blindly
    adding new features to HTML would result in an even more bloated
    standard} with a lot of backward compatability to maintain - a
  modern browser must still be compatible with the bugs in Netscape
  versions 2 and 3.  These were renowned for being very lenient
  towards users providing erroneous HTML, and have started a tradition
  of browsers doing their best to interpret what the users
  \emph{might} have meant.  This makes it hard to use HTML as a
  generic information data format, since parsers are complex due to
  the many exceptions.  }

The W3C took a bold step in saying:  We need a new format - the
eXtensible Markup Language.  XML!


\section{The \textsf{creation} of XML}

XML was as HTML built on SGML, but with a much stricter syntax than
HTML and a lot less facilities than in SGML.  XML is a new standard -
it was made a W3C recommandation in 1998, and the
accompanying XSLT and XPath in November 1999.

\textsf{What was the design goals}

The resulting language for designing languages has these features:
\begin{itemize}
\item A very strict syntax which every XML-document must comply to
  (which is what a \emph{well-formed} document does).
  All open tags must be closed explicitely.  Tag attribute values must
  be in quotes.
  
\item Easy to parse and generate.  The strict syntax makes the parser
  much simpler than a SGML parser.

\item The DTD is not mandatory.  DTD-less documents does not have a
  DTD to conform to, and must only be well-formed.  \textsf{Unicode?}
\end{itemize}

\textsf{TRANSFORMATON}

\textsf{FORMATTING}



\section{XHTML - XML compliant HTML}

[\myurl{http://www.w3.org/TR/xhtml1/}{The XHTML W3C recommandation}.]

A big problem with XML in general is that it cannot be viewed by
anything the majority of users have today.  It is possible, however,
to specify a form of XML called \textit{XHTML} which bridges the gap
between the two worlds of XML and HTML.  Documents corresponding to a
XHTML DTD are parsable by HTML-4.0 compliant browsers if a few, simple
guidelines are followed:

\begin{itemize}
\item Elements (the HTML tags) must be closed correctly.
  
\item Attribute values must be quoted
\item Element names and attributes must be given in lower case
  
\item Empty elements must either have an end tag, or the start tag
  must end with ``/$>$''.  I.e. a horizontal line which is written as
  \tag{hr} in HTML, must be written as
  ``$<$hr /$>$'', where the space is important to make this acceptable
  to HTML-4.0 parsers.
%\item \textsf{More stuff... Netvwork lag}
\end{itemize}

The well-formedness of an XHTML document is achieved\textsf{...}

\begin{verbatim}
HTML: <hr noshade>
XML:  <hr noshade="" />
\end{verbatim}


\textsf{Why is this smart???  Not only pure output but also input for
  another XML transformation}  

\textit{
\textsf{XHTML} is an XML-variant designed to be viewable in HTML-4.0
compatible browsers (without XML support).  XHTML-documents are
well-formed XML documents, while at the same time being valid
HTML-4.0, so that XHTML can be the target of a standard
XML-\textit{transformation} as well as a source for initial
XML-processing.}

This is very different from the usual situation, namely that HTML is
the result from \textit{formatting} a document, where the result is
not XML any more.


\textsf{Note: XHTML style sheet generated files does not trigger
  correct change to UTF-7 characterset.}

\textsf{WHICH CONVERSION UTILITIES ARE THERE?  TIDY?  READ XHTML?
  WRITE XHTML?  WHAT DO W3C SUGGEST?  WHY DO THEY THINK THIS IS A GOOD
  IDEA}

\section{Which dialect of SGML should be used?}

The Document Type Definition (\emph{DTD}) defines exactly the way a
SGML/XML document can look, when conforming to the DTD.

\begin{itemize}
\item which tags are valid
\item which tags can appear at any given part of a document
\item which attributes are valid for a given tag
\item which \emph{entities} (macros) can appear in a document, both
  for expansion strings but also for Unicode characters unavailable to
  the document author
  
\item \textsf{Others?}
\end{itemize}

There is a lot of different DTD's available to many different
purposes, since basically everywhere a datafile is needed XML can be
used with a suitable DTD.   \textsf{ChemML}, \textsf{SVG?}.  If a need
arises it is just a matter of creating a suitable DTD to work with it.

Unfortunately, for each and every pair of DTD and output format an
XSL-style sheet must be written, tested and maintained.  Therefore it
is a very good idea to use a commonly used, documented, and
well-thoughtout DTD for the documents, and several other groups have
already done such work. 


The Cactus system uses the DocBook XML V3.1.7 DTD with the
DocBook XSL \textsf{-------------------}

\section{How can a *ML document be viewed?}

In order to be rendered into a view, a \textit{style sheet} must be
applied to the document.  Style sheets convert the tags in the
document to a given output format, and depends on (DTD, output format
pairs).


\textsf{GRAPH DEPICTING STYLE SHEETS BEING APPLIED FOR DIFFERENT
  OUTPUT FORMATS}





Commecial products usually have a viewer which can apply the style
sheet directly \texttt{examples? Panorama? Framemaker+SGML}, but are
due to licensing costs and supported user base rarely an option for
general for documents targeting end-users, and I have not tried any of
them.  Table~\vref{tab:distribution-formats} discusses the current
\textit{de facto} document formats on the Internet.


\begin{table}[htbp]
  \begin{center}
    \begin{tabular}{|l|p{10cm}|}
      \hline\hline
      Format & \\
      \hline

      HTML & Browsers are available for any modern platform.  HTML-4.0
      compliant browsers are Netscape Navigator 4, Internet Explorer
      4... \textsf{More?} \\ 
      
      PDF & Adobe Acrobat Reader is available for most
      mainstream platforms \textsf{URL}.  The Adobe Acrobat Viewer is
      available for any platform with Java \textsf{URL}.  The Open
      Source project Ghostscript \textsf{URL} is available for these
      and other platforms. \\
  
      
      Microsoft Word & The \texttt{doc} and \texttt{rtf} file formats
      are widely used, but needs a full word processor to format
      properly.  Anything else but Microsoft Word gives inferior
      results, and Word only runs on Windows.
      \\
      PS & \\
      PDF &\\

      \hline
    \end{tabular}
    \caption{Frequently encountered document distribution formats}
    \label{tab:distribution-formats}
  \end{center}
\end{table}


The Microsoft Internet Explorer 5.5 (not yet available at the time of
writing) will be able to transform XML documents with XSL-style sheets
internally complying with the W3C recommendation.  The previous
version of IE was available on Windows, Solaris and HPUX.

The Mozilla browser in its pending release as Netscape Navigator 5.0
will not be able to apply XSL-style sheets, but only CSS cascading
style sheets.  This \textsf{decision is rather old and may have
  changed}. 

For the immediate future web publishing in XML implies a need for
server side conversion to other formats.  The available Open Source
software for this is surprisingly small, but that is rapidly
changing.  Please note that XML style sheets still implies SGML style
sheets, which is interesting because these are more mature due to
longer use (see section\~vref{sec:docbook-xml-to-rtf} for more
details). 


\subsection{SGML style sheets}

\textsf{CONFIRM THE BEHAVIOUR WRITTEN BELOW IS EXCACT}

SGML style sheets are \textsf{written in DSSSL} (others?), which is
a Lisp-dialect, and the usual Lisp-conventions apply.  Several

\textsf{several?} \textsf{what can this do?}

The DocBook reference recommends using \texttt{jade} written by James
Clark, to do DSSSL conversions.  \textsf{long processing times later
  implemented in XT with threads to allow faster output}.  

\textsf{Show a sample stylesheet}

\subsection{XML style sheets}

XSL - the XML style sheets - are written in XML too.  The tags in the
name space ``xsl:'' describe what is to be done with the source XML
tree, in terms of tag-remapping (\tag{para} to \tag{p}), sorting
of subtrees, and several programming constructions like ``if'',
``while'' and ``foreach''.  New tags can be constructed, existing tags
can be altered, and \textsf{yes?}

\textsf{a reference listing here}

This style sheet - lifted from the DocBook distribution - creates an
outline of a DocBook document by looking for headline tags, and make a
tree of them \textsf{Eh? }  Line breaks have been introduced for
readability.

{\small
\verbatiminput{x-outline.xsl}
}






Since the DocBook reference is very vague on this matter (the book
went to press before the XSLT recommendation was finalized) the
Internet has been a great help.
Table~\vref{tab:leading-xslt-processors} lists the tested XSLT
processors which conforms to the W3C XSLT-19991102 recommendation.  

% \textsf{Where should I talk about SAX?}

\begin{table}[htbp]
  \begin{center}
    \begin{tabular}{|l|p{10cm}|}

      \hline\hline
      
      XT &  XSLT processor based on the XP parser.  Both
      written in Java\textsf{ by James Clark}. \\

      Xalan & XSLT processor written in Java originally based on the
      LotusXSL processor by \textsf{alphaworks?}.   Currenly under
      heavy development by the Cocoon team 
      (\texttt{xml.apache.org}). \\
      
      \hline
    \end{tabular}
    \caption{Leading XSLT processors implementing
      \textsf{XSLT-19991102} in February 2000} 
    \label{tab:leading-xslt-processors}
  \end{center}
\end{table}

During testing it showed very quickly that the Java tools are quick
enough to use for casual use (\textsf{do a few benchmarks}), even
though they are not yet tuned for optimal performance.  Additionally


Even so, implementations in C
should only be considered by designers if Java clearly cannot do the
job.  The advantages of Java over C (\textsf{reference big list,
  probably at JavaSoft?}) in program development

\begin{itemize}
\item Very hard to do pointer access
\item A large set of tested libries
\end{itemize}

Xalan is at the time of this writing in a development state, and
contains bugs which causes it to crash on some of my sample DocBook
XML document.  After that I turned to XT which is extremely stable and
reliable, and that I have used for the rest of the project - my only
complaint is that it stops after reporting the first error instead of
parsing the whole document.


When the Cocoon project stabilizes they will have a
high end XSLT-engine embedded as a servlet in Apache, which makes this
a project to watch.  The technology is at the time of this writing
still immature, but very promising.

The platform independance of Java indirectly prompted the
implementation of remote filters in Cactus.  Very early in the
evaluation Xalan threw the above mentioned exception when processing a
medium sized DocBook document.  In order to rule out errors in the
underlying Java environment on Asserballe (see
section~\vref{sec:asserballe} for technical details) an identical run
was made with JDK 1.2 on Aalborg.  The same error occured, but in less
than one second instead of ten.  Experiments showed that Java programs
consistently runs 15 times faster on Aalborg than on Asserballe.
\textsf{and so what?}

\textsf{\texttt{incoming.xml}}
\begin{verbatim}
<?xml version="1.0"?>
<?xml-stylesheet href="incoming.xsl" type="text/xsl"?>

<?cocoon-process type="sql"?>
<?cocoon-process type="xslt"?>

<page>

 <connectiondefs>
  <connection name="foo_connection">
   <driver>org.gjt.mm.mysql.Driver</driver>
   <dburl>jdbc:mysql://localhost/Cactus</dburl>
   <username>XXXXXXXXX</username>
   <password>XXXXXXXXX</password>
  </connection>
 </connectiondefs> 
 
 <query connection="foo_connection" tag-case="lower">
  select when, mime, user, how, filename, comment,length(item) as l  from incoming
 </query>

Testing 
</page>
\end{verbatim}

\texttt{incoming.xsl}
\begin{verbatim}
<?xml version="1.0" ?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<?cocoon-process type="xslt"?>

<xsl:template match="page">
<html>
<head>
<title><xsl:value-of select="title"/></title>
</head>
<body bgcolor="#ffffff">
<img src="gr/organ_pipe_cactus-single.jpg" align="left" />
<xsl:apply-templates/>
</body>
</html>
</xsl:template>

<xsl:template match="ROWSET">
<table border="0" bgcolor="#F0F0F0">
<tr><th>when</th><th>mime</th><th>user</th><th>how</th><th>filename</th><th>comment</th><th>iteml</th></tr>
<xsl:apply-templates/>
</table>
</xsl:template>


<xsl:template match="ROW">
<tr> 
<td><xsl:value-of select="when"/></td>
<td><xsl:value-of select="mime"/></td>
<td><xsl:value-of select="user"/></td>
<td><xsl:value-of select="how"/></td>
<td><xsl:value-of select="filename"/></td>
<td><xsl:value-of select="comment"/></td>
<td><xsl:value-of select="l"/></td>
</tr>
</xsl:template>
</xsl:stylesheet>
\end{verbatim}


\section{Converting documents to XML}

XML is currently having the same problems that HTML had in its initial
years, namely lack of software support.  The difference is that HTML
is so lenient that it is easy to write HTML by hand in a text editor.
Not so with XML.

The difference this time is that Microsoft has been an active
participant in the \textsf{definition of XML}, and has made
\textsf{???} about Windows 2000 supporting XML directly \textsf{in
  what precisely?}

Even so there is still a severe lack of conversion tools for the many
files out there in non-SGML based formats like Word, Excel, {\LaTeX},
{\TeX}, Lotus Notes, etc., which must be available before the
documents can be converted.    

\begin{table}[htbp]
  \begin{center}
    \begin{tabular}{|l|p{10cm}|}
      \hline\hline
      Majix & Java based RTF to XML, which I have adapted to DocBook
      \\
      pod2docbook & Converts Perl documentation to XML
      \\
      wordview\textsf{others} \textsf{sp?} & Converts \textsf{Word 6-95-97} to
      HTML.  I have adapted them to produce DocBook output
      \textsf{better do it too}
      \\
      tex4h & package for {\LaTeX} which can \textsf{what was it now?}
      \\
      \textsf{others} & ??
      \\
      \hline
    \end{tabular}
    \caption{Conversion tools to XML [February 2000]}
    \label{tab:conversion-tools-to-xml}
  \end{center}
\end{table}
\textsf{
Due to the rather inflexible DTD-requirements in XML, it is most
convenient that such a tool generates stand-alone XML (\textsf{SGML ok
  if it can be converted?  With what?}), which can be processed freely
in the system.  This is hopefully something which gets resolved soon,
since the validation of the tree structure in an XML document is as
important as it being well-formed. \textsf{rewrite.}
}
\textsf{Move filter descriptions to Cactus chapter discussing
  filters?  ... wordperf 9 should be ablt ot do sgml} 
\subsection{Majix - RTF/(DOC) to XML}

Majix \textsf{URL, company description} is an RTF (for Word 97
documents) to XML converter.  I have created a configuration and a
small style-sheet which can render a RTF file to DocBook XML.

If run with the Microsoft Java Machine (\ntcommand{jview}) while logged
into a Windows machine with access to the GUI, it can launch Word to
convert a given DOC file to RTF and process it, with very reasonable
results.  I have experimented with making this accessible to Linux by
installing Microsoft Services for Unix on a NT machine with Word
installed, and using telnet to invoke Majix.  Unfortunately this
doesn't work.  Another approaches (\textsf{which will be tested if
  time allows}) includes having a pseudo-user watching a directory on
a NT-server and launching Majix whenever DOC or RTF documents arive.
These can at best be described as kludges.

Even though it shows great promise, it has been a year without new
releases (including the promised Pro version), and the source is not
available. 

Conclusion: The Majix software is currently best for personal end-user
conversions.


\subsection{pod2docbook - POD to XML}

The POD format is created for writing documentation for the Perl
programming language, and was created to be ``\ldots an idiot- proof
common source for nroff, TeX, and other markup languages, as used for
online documentation'' by Larry Wall (\textsf{the perlpod manual
  page}).
       
The original release produced SGML DocBook.  I have submitted patches
to the author which allows the user to choose between XML and SGML
DocBook.

Conclusion:  This do a good job for documents written in POD, and will
probably with time take over as the default formatter for printed
versions of Perl documentation.

\subsection{tex4h - convert {\TeX} to XML}

\textsf{What daelen does it do}      
      
\textsf{Conclusion:}

\subsection{wordview with friends}

\textsf{Parses binary stream and produces HTML, WML plus more.  }


\section{Rendering HTML on the fly}

\textsf{look at docs.sun.com - what daelen do they do?  Render SGML to
  HTML on the fly?}

When the decision has been made to provide information in *ML on the
web server, another decision must be made.  Should the various
renderings to PDF and HTML be created before they are requested, or
when the user asks for a certain rendering?

% Table~\ref{tab:static-and-dynamic-rendering} discusses the arguments. 

% \begin{table}[htbp]
%   \begin{center}
%     \begin{tabular}{|l|p{10cm}|}
%       \hline\hline
      
%     \end{tabular}
%     \caption{Static and dynamic rendering of *XML}
%     \label{tab:static-and-dynamic-rendering}
%   \end{center}
% \end{table}

\textsf{Look for an article on static versus dynamic}

As always it depends on the nature of the data.

\textit{Static renderings} is probably suitable for documents which
rarely change their rendering or take long time to render, and which
just must be served as fast as possible.  Often there is a desire for
an inexpensive solution\footnote{``Inexpensive'' here is defined in
  terms of man hours needed to learn and maintain the web server, as
  well as the hardware needed}, and in that case a standard Apache
with a rich set of prerendered documents in a flat file system may
very well be optimal.  Personal experience has shown this to be a very
robust solution which very rarely requires human intervention.
\textsf{\textsf{esr} Eric S. Raymond reports that a modern PC with Apache is
easily capable of saturating a 10Mbps ethernet connection.
}

\textsf{
\textit{Dynamic rendering} is suitable whenever the data changes very
often, or there is a wish for the user to be able to personalize their
view of the presented documents , or if the conversion
process is light and
(should frames be used or not?  do the
user want large or small versions of images?)
}




\framepage{15cm}{
The history and usage of SGML.  Creation of XML.  Describe document
validation, and conversion (XSLT) to XML and other formats.  Freedom
from restrictions of HTML.  Problems with tons and tons of DTD's.  The
need for well-documented standard, robust, supported DTD's (current
ones: TEI, ebook [buh], DocBook).  HTML conversion utilities can be
tailored to generated DocBook XML for SSP (currently pod2docbook,
Excel xls2xml).  Found that SGML (jade) is powerful but too slow for
on-the-fly stuff, as opposed to XML rendererer.  Several to choose
from if they conform to the w3c standards (DOM and SAX).   Who uses DocBook at
the moment?  Man pages in DocBook on Solaris (look on machine).  IE50
cannot show ``simple'' DocBook XML yet but it is the goal of that
project.

the xsl/docbook/contrib/outline/outline.xsl is an excellent sample of
a small, powerful style sheet.
}

% $Log$
% Revision 1.10  2000/03/23 15:51:07  ravn
%
% Rearranged a lot of stuff, and starting to fill out the stuff Immerkaer
% told me.
%
% Revision 1.9  2000/03/20 13:02:50  ravn
%
% Added all updates from looktrhough at home.
%
% Revision 1.8  2000/03/18 06:06:51  ravn
% Wrote a lot on the dynam,ically generated chapter with a lot of information regarding the need for meta-information stored in the files, plus added screen shos
%
% Revision 1.7  2000/03/14 19:29:50  ravn
%
% Updated after working athome.  Major restructuring and moving stuff around.
%
% Revision 1.6  2000/03/10 05:41:37  ravn
%  wrote a lot about SQLand some about LaTeX
%
% Revision 1.5  2000/03/08 07:38:04  ravn
% Tried to remove PNG files
%
% Revision 1.4  2000/03/08 06:51:12  ravn
% Edited a lot of text in XML
%
% Revision 1.3  2000/03/05 02:32:16  ravn
% Added lots of pictures with relatively little dialoue.
%
% Making progress.
%
% Revision 1.2  2000/03/04 21:39:15  ravn
%
%
% Added a lot of information.  Prepared for screendumps.
%
% Revision 1.1.1.1  2000/03/02 21:55:31  ravn
% Speciale files
%
% Revision 1.3  2000/02/26 22:07:33  ravn
% Filled stuff on the various XSLT processors and described the findings hereof.
%
% Revision 1.2  2000/02/26 15:57:39  ravn
% Added a lot of text at the latter part.
%
% Revision 1.1  2000/02/23 02:23:26  ravn
% Initial revision
%
%

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "rapport"
%%% End: 
